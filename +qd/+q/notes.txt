The q module is designed to replace the run module. It is work in progress,
below are some examples of how I want the API to behave.

job = recipe.apply(ctx, sub_job)
ctx.resolve_channel(channel_name_or_obj) -> channel object

(recipe1 | recipe2).apply(ctx, job) =
    recipe1.apply(ctx, recipe2.apply(ctx, job))

job.exec(ctx, future, settle, prefix)
job.time(options, settling_time)
job.total_points() -- should recurse into subordinate jobs, may return NaN or
    inf as is appropriate.
job.reversed() -> a new job.
job.columns() -> a cell array of json serializeable 
                 structs with at least a name field.
job.describe(register) -> json serializeable object
ctx.add_point(point)
Note, ctx.add_point may raise an exception.
In addition to points, we also need to put a blank line after every inner
sweep to make gnuplot happy.
ctx.add_divider()
The following function should be called once in a while to process hooks
from outside.
ctx.periodic_hook()

q = qd.q.Q()
q.store = ...
q.setup = ...
q.add_input(chan) -- Note, in contrast to with() below, this method modifies q.
q.cellphone = '+4520786406'

All below methods return a fresh object. They do not modify q.
q.do(qd.q.until('3 am') | sw('g4', ...)).go('name')
q.as('name').sw('g4', ...).without('lock-in/curr').go()
q.sw('g3', ...).with(some_input).time()
q.sw('gate', ...).do(bias_sweep).send_sms().go('name')
q.go(sw('g2', ...) | sw('bias', ...), 'name')

inputs = qd.q.impl.Inputs()
inputs.with(chan_obj) -> fresh object
inputs.without(name) -> fresh object
inputs.read() -> array of doubles
inputs.columns()
inputs.describe(register) -> json serializeable object